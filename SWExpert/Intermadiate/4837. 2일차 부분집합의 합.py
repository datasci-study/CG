'''
1부터 12까지의 숫자를 원소로 가진 집합 A가 있다. 집합 A의 부분 집합 중 N개의 원소를 갖고 있고, 원소의 합이 K인 부분집합의 개수를 출력하는 프로그램을 작성하시오.
해당하는 부분집합이 없는 경우 0을 출력한다. 모든 부분 집합을 만들어 답을 찾아도 된다. 
예를 들어 N = 3, K = 6 경우, 부분집합은 { 1, 2, 3 } 경우 1가지가 존재한다.

[입력]
첫 줄에 테스트 케이스 개수 T가 주어진다.  ( 1 ≤ T ≤ 50 )
테스트 케이스 별로 부분집합 원소의 수 N과 부분 집합의 합 K가 여백을 두고 주어진다. ( 1 ≤ N ≤ 12, 1 ≤ K ≤ 100 )

[출력]
각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

[입력 예]
3
3 6
5 15
5 10

[출력 예]
#1 1
#2 1
#3 0
'''

T = int(input()) # T 입력
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
n = len(arr)
for l in range(T): # T회 반복
    N, K = map(int, input().split()) # N : N개의 원소, K : K개의 원소의 합
    result = [] # 조건을 만족하는 배열을 저장할 리스트
    # 모든 부분 집합 중 조건에 맞는 set만 저장
    for i in range(1<<n): # 원소의 갯수 n개 일 경우 모든 부분 집합의 수를 의미    
        temp = [] # 조건에 맞는 부분집합을 저장할 리스트, 한 번 돌 때마다 temp를 초기화 
        for j in range(n): # 부분집합의 갯수 0개일때부터 6개 일때까지
            if i & (1<<j): # 1<<j : i에서 j번째 비트가 1인지 아닌지를 리턴함 (부분집합이면 진행)
                temp.append(arr[j]) # temp에 부분 집합을 저장
                if temp in result: # 이미 저장되어 있는 부분 집합이라면 무시
                    pass
                else: # 아니라면
                    if sum(temp) == K and len(temp) == N: # 부분집합의 합(sum(temp))이 K이고 갯수(len(temp))가 N인 set만 저장하여 result에 append
                        result.append(temp)
    #양식에 맞게 출력
    print("#{0} {1}".format(l+1, len(result)))
